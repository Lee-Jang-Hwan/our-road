# ëŒ€ì¤‘êµí†µ ì•Œê³ ë¦¬ì¦˜ ì½”ë“œ ê°œì„  ì‚¬í•­

> ì‘ì„±ì¼: 2026-01-05
>
> ì „ì²´ ì½”ë“œë² ì´ìŠ¤ë¥¼ ì‹¬ì¸µ ë¶„ì„í•˜ì—¬ ë°œê²¬ëœ ë¬¸ì œì ë“¤ì„ ìˆ˜ì •í•˜ê³  ì•ˆì •ì„±ì„ í¬ê²Œ í–¥ìƒì‹œì¼°ìŠµë‹ˆë‹¤.

---

## ğŸš¨ ë°œê²¬ë˜ê³  ìˆ˜ì •ëœ ì£¼ìš” ë¬¸ì œì 

### 1. **Clustering ë¡œì§ì˜ ì‹¬ê°í•œ ë²„ê·¸ ìˆ˜ì •**

#### ë¬¸ì œì 
- `ensureFixedWaypointsIncluded`ì—ì„œ fixedWaypointë¥¼ ì°¾ì„ ë•Œ ì´ë¯¸ í• ë‹¹ëœ waypointsì—ì„œë§Œ ê²€ìƒ‰
- ì›ë³¸ waypoints ë°°ì—´ì—ì„œ ì°¾ì§€ ëª»í•´ í•„ìˆ˜ ê²½ìœ ì§€ê°€ ëˆ„ë½ë  ìˆ˜ ìˆìŒ

#### í•´ê²°
```typescript
// Before: ì´ë¯¸ í• ë‹¹ëœ waypointsì—ì„œë§Œ ê²€ìƒ‰ (ë²„ê·¸)
const allWaypoints = clusters.flatMap((cluster) => cluster.waypoints);
const fixedWaypoint = allWaypoints.find((wp) => wp.id === fixedId);

// After: ì›ë³¸ waypointsì—ì„œ ê²€ìƒ‰ (ìˆ˜ì •)
export function ensureFixedWaypointsIncluded(
  clusters: ClusterBuilder[],
  fixedIds: string[],
  allWaypoints: Waypoint[] // ì›ë³¸ waypoints ì¶”ê°€
): void {
  const fixedWaypoint = allWaypoints.find((wp) => wp.id === fixedId);
}
```

### 2. **balanceClusterSizesì˜ ì¹˜ëª…ì  ê²°í•¨ ìˆ˜ì •**

#### ë¬¸ì œì 
- Seed waypointë¥¼ ì´ë™ì‹œí‚¬ ìˆ˜ ìˆìŒ â†’ í´ëŸ¬ìŠ¤í„° êµ¬ì¡° íŒŒê´´
- í•„ìˆ˜ ê²½ìœ ì§€(`isFixed`)ë¥¼ ì´ë™ì‹œí‚¬ ìˆ˜ ìˆìŒ â†’ ìš”êµ¬ì‚¬í•­ ìœ„ë°˜
- Day-locked ê²½ìœ ì§€ë¥¼ ì´ë™ì‹œí‚¬ ìˆ˜ ìˆìŒ â†’ ì¼ì • ì œì•½ ìœ„ë°˜

#### í•´ê²°
```typescript
// Before: ëª¨ë“  waypointë¥¼ ì´ë™ ëŒ€ìƒìœ¼ë¡œ ê°„ì£¼
const candidate = largest.waypoints
  .map((wp) => ({ wp, distance }))
  .sort((a, b) => a.distance - b.distance)[0];

// After: ì´ë™ ê°€ëŠ¥í•œ waypointë§Œ í•„í„°ë§
const movableWaypoints = largest.waypoints.filter(
  (wp) => wp.id !== largest.seed.id && !wp.isFixed && !wp.dayLock
);

const candidate = movableWaypoints
  .map((wp) => ({ wp, distance }))
  .sort((a, b) => a.distance - b.distance)[0];
```

### 3. **Empty Cluster ì²˜ë¦¬ ì¶”ê°€**

#### ë¬¸ì œì 
- ê· í˜•í™” í›„ ë¹ˆ í´ëŸ¬ìŠ¤í„°ê°€ ìƒê¸¸ ìˆ˜ ìˆìŒ
- ë¹ˆ í´ëŸ¬ìŠ¤í„°ê°€ dayPlans ìƒì„± ì‹œ ì˜¤ë¥˜ ë°œìƒ ê°€ëŠ¥

#### í•´ê²°
```typescript
// Filter out empty clusters
const nonEmptyClusters = clusters.filter((c) => c.waypoints.length > 0);

if (nonEmptyClusters.length === 0) {
  throw new Error("All clusters are empty after balancing");
}

return nonEmptyClusters.map((cluster, index) => ({
  clusterId: `cluster-${index + 1}`,
  dayIndex: index + 1,
  waypointIds: cluster.waypoints.map((wp) => wp.id),
  centroid: calculateCentroid(cluster.waypoints.map((wp) => wp.coord)),
}));
```

### 4. **ë¬´í•œ ë£¨í”„ ìœ„í—˜ ì œê±°**

#### ë¬¸ì œì 
- `exceedsDailyLimitProxy` ë¬´í•œ ë£¨í”„ ê°€ëŠ¥ì„±
- ì œê±° ê°€ëŠ¥í•œ ê²½ìœ ì§€ê°€ ì—†ì–´ë„ ê³„ì† ë°˜ë³µ

#### í•´ê²°
```typescript
// Before: ë¬´í•œ ë£¨í”„ ìœ„í—˜
while (exceedsDailyLimitProxy(dayPlans, input.dailyMaxMinutes, waypointMap)) {
  const worstPoint = selectWorstComplexityPoint(dayPlans, fixedIds, waypointMap);
  if (!worstPoint) break; // ì´ê²ƒë§Œìœ¼ë¡œ ë¶€ì¡±
  removeWaypoint(dayPlans, worstPoint);
}

// After: ì•ˆì „ ì¥ì¹˜ ì¶”ê°€
const maxRemovalIterations = Math.floor(waypoints.length * 0.5); // ìµœëŒ€ 50%ë§Œ ì œê±°
let removalCount = 0;

while (
  exceedsDailyLimitProxy(dayPlans, input.dailyMaxMinutes, waypointMap) &&
  removalCount < maxRemovalIterations
) {
  const worstPoint = selectWorstComplexityPoint(dayPlans, fixedIds, waypointMap);
  if (!worstPoint) {
    console.warn("Cannot meet daily time limit: no removable waypoints");
    break;
  }
  removeWaypoint(dayPlans, worstPoint);
  removalCount++;
}

if (removalCount >= maxRemovalIterations) {
  console.warn(`Reached max removal limit (${maxRemovalIterations})`);
}
```

---

## ğŸ”§ ì „ë°˜ì ì¸ ê°œì„  ì‚¬í•­

### 5. **ì…ë ¥ ê²€ì¦ ê°•í™” (preprocess.ts)**

#### ì¶”ê°€ëœ ê²€ì¦
- Waypoints ë°°ì—´ íƒ€ì… ê²€ì¦
- ì¤‘ë³µ ID ê°ì§€ ë° ê²½ê³ 
- ì¢Œí‘œ ìœ íš¨ì„± ìƒì„¸ ê²€ì¦
- êµ¬ì¡°ì  ë¬´ê²°ì„± ê²€ì‚¬

```typescript
export function preprocessWaypoints(waypoints: Waypoint[]): Waypoint[] {
  if (!Array.isArray(waypoints)) {
    throw new Error("Waypoints must be an array");
  }

  const seenIds = new Set<string>();

  for (const waypoint of waypoints) {
    // ê°ì²´ ìœ íš¨ì„± ê²€ì‚¬
    if (!waypoint || typeof waypoint !== "object") {
      console.warn("Invalid waypoint object, skipping");
      continue;
    }

    // ID ê²€ì¦
    if (!waypoint.id || typeof waypoint.id !== "string") {
      console.warn("Waypoint missing valid ID, skipping");
      continue;
    }

    // ì¤‘ë³µ ID ê²€ì‚¬
    if (seenIds.has(waypoint.id)) {
      console.warn(`Duplicate waypoint ID ${waypoint.id}, skipping`);
      continue;
    }
    seenIds.add(waypoint.id);

    // ì¢Œí‘œ ê²€ì¦
    if (!waypoint.coord || typeof waypoint.coord !== "object") {
      console.warn(`Waypoint ${waypoint.id} missing coordinates`);
      continue;
    }

    // ... ê¸°ì¡´ ë¡œì§
  }

  if (cleaned.length === 0) {
    throw new Error("No valid waypoints after preprocessing");
  }

  return cleaned;
}
```

### 6. **geo ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ê°•í™”**

#### calculateDistance
```typescript
export function calculateDistance(a: LatLng, b: LatLng): number {
  // ì…ë ¥ ê²€ì¦ ì¶”ê°€
  if (
    !a || !b ||
    !Number.isFinite(a.lat) || !Number.isFinite(a.lng) ||
    !Number.isFinite(b.lat) || !Number.isFinite(b.lng)
  ) {
    throw new Error("Invalid coordinates for distance calculation");
  }
  // ... Haversine formula
}
```

#### calculateCentroid
```typescript
export function calculateCentroid(points: LatLng[]): LatLng {
  if (!Array.isArray(points) || points.length === 0) {
    throw new Error("Cannot calculate centroid of empty points array");
  }

  // ìœ íš¨í•œ í¬ì¸íŠ¸ë§Œ í•„í„°ë§
  const validPoints = points.filter(
    (p) =>
      p &&
      typeof p === "object" &&
      Number.isFinite(p.lat) &&
      Number.isFinite(p.lng)
  );

  if (validPoints.length === 0) {
    throw new Error("No valid points to calculate centroid");
  }

  // ... ê³„ì‚° ë¡œì§
}
```

### 7. **API í˜¸ì¶œ ì¬ì‹œë„ ë¡œì§ ì¶”ê°€**

#### ì£¼ìš” ê°œì„  ì‚¬í•­
- Exponential backoff ì¬ì‹œë„ ì „ëµ
- ë°°ì¹˜ ê°„ ë”œë ˆì´ë¡œ rate limiting ë°©ì§€
- ìƒì„¸í•œ ì—ëŸ¬ ë¡œê¹…

```typescript
export async function callRoutingAPIForSegments(
  segments: SegmentRequest[]
): Promise<SegmentCost[]> {
  if (!Array.isArray(segments) || segments.length === 0) {
    return [];
  }

  const maxRetries = 2;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const route = await getBestTransitRouteWithDetails(
        segment.fromCoord,
        segment.toCoord
      );

      if (!route) {
        if (attempt === maxRetries) {
          console.warn(`No route found, using fallback`);
          return fallbackSegmentCost(segment);
        }
        continue; // Retry
      }

      return { /* ì„±ê³µ */ };
    } catch (error) {
      if (attempt === maxRetries) {
        console.error(`Error fetching route:`, error);
        return fallbackSegmentCost(segment);
      }
      // Exponential backoff
      await new Promise((resolve) =>
        setTimeout(resolve, Math.pow(2, attempt) * 100)
      );
    }
  }
}
```

### 8. **complexity-removal ë¡œì§ ê°•í™”**

#### exceedsDailyLimitProxy ê°œì„ 
```typescript
export function exceedsDailyLimitProxy(
  dayPlans: DayPlan[],
  dailyMaxMinutes: number,
  waypoints: Map<string, Waypoint>
): boolean {
  // ì…ë ¥ ê²€ì¦ ì¶”ê°€
  if (!Array.isArray(dayPlans) || dayPlans.length === 0) {
    return false;
  }

  if (!Number.isFinite(dailyMaxMinutes) || dailyMaxMinutes <= 0) {
    return false;
  }

  return dayPlans.some((dayPlan) => {
    if (!dayPlan || !Array.isArray(dayPlan.waypointOrder)) {
      return false;
    }

    const route = dayPlan.waypointOrder;
    if (route.length < 2) {
      return false;
    }

    let distanceMeters = 0;
    let validSegments = 0;

    for (let i = 0; i < route.length - 1; i++) {
      try {
        distanceMeters += calculateDistance(from.coord, to.coord);
        validSegments++;
      } catch (error) {
        console.warn(`Error calculating distance:`, error);
      }
    }

    if (validSegments === 0) {
      return false;
    }

    // ... ê³„ì‚°
  });
}
```

### 9. **ë©”ì¸ í•¨ìˆ˜ ì…ë ¥ ê²€ì¦**

#### generatePublicTransitRoute ê°œì„ 
```typescript
export async function generatePublicTransitRoute(
  input: TripInput
): Promise<TripOutput> {
  // í¬ê´„ì ì¸ ì…ë ¥ ê²€ì¦
  if (!input || typeof input !== "object") {
    throw new Error("Invalid input: must be a TripInput object");
  }

  if (!input.tripId || typeof input.tripId !== "string") {
    throw new Error("Invalid input: tripId is required");
  }

  if (!Number.isFinite(input.days) || input.days <= 0) {
    throw new Error("Invalid input: days must be a positive number");
  }

  if (!input.start || !input.start.lat || !input.start.lng) {
    throw new Error("Invalid input: start coordinate is required");
  }

  if (!Array.isArray(input.waypoints) || input.waypoints.length === 0) {
    throw new Error("Invalid input: waypoints array is required");
  }

  // ... ë¡œì§ ì‹¤í–‰
}
```

### 10. **Cluster Ordering ê²€ì¦ ê°•í™”**

#### chooseEndAnchor
```typescript
export function chooseEndAnchor(
  lodging: LatLng | undefined,
  clusters: Cluster[],
  _days: number
): LatLng {
  if (lodging) {
    return lodging;
  }

  if (!Array.isArray(clusters) || clusters.length === 0) {
    throw new Error("Cannot choose end anchor from empty clusters");
  }

  const centroids = clusters.map((cluster) => cluster.centroid);
  const average = calculateCentroid(centroids);
  const farthest = centroids.sort(
    (a, b) => calculateDistance(b, average) - calculateDistance(a, average)
  )[0];

  if (!farthest) {
    throw new Error("Failed to determine end anchor");
  }

  return farthest;
}
```

#### orderClustersOneDirection
```typescript
export function orderClustersOneDirection(
  clusters: Cluster[],
  endAnchor: LatLng
): Cluster[] {
  if (!Array.isArray(clusters) || clusters.length === 0) {
    throw new Error("Cannot order empty clusters");
  }

  if (!endAnchor || !Number.isFinite(endAnchor.lat) || !Number.isFinite(endAnchor.lng)) {
    throw new Error("Invalid end anchor coordinates");
  }

  // ... ì •ë ¬ ë¡œì§
}
```

### 11. **extractSegments ê²€ì¦ ì¶”ê°€**

```typescript
export function extractSegments(
  dayPlans: DayPlan[],
  waypoints: Map<string, Waypoint>,
  start: LatLng,
  end?: LatLng,
  lodging?: LatLng
): SegmentRequest[] {
  if (!Array.isArray(dayPlans) || dayPlans.length === 0) {
    console.warn("[extractSegments] No day plans provided");
    return [];
  }

  if (!waypoints || waypoints.size === 0) {
    console.warn("[extractSegments] No waypoints provided");
    return [];
  }

  if (!start || !Number.isFinite(start.lat) || !Number.isFinite(start.lng)) {
    throw new Error("Invalid start coordinates");
  }

  const getWaypointCoord = (id: string): LatLng | null => {
    if (!id) return null;
    const waypoint = waypoints.get(id);
    return waypoint ? waypoint.coord : null;
  };

  for (let dayIndex = 0; dayIndex < dayPlans.length; dayIndex++) {
    const dayPlan = dayPlans[dayIndex];
    if (!dayPlan || !Array.isArray(dayPlan.waypointOrder)) {
      console.warn(`Invalid day plan at index ${dayIndex}`);
      continue;
    }
    // ... ì¶”ì¶œ ë¡œì§
  }
}
```

---

## ğŸ“Š ê°œì„  íš¨ê³¼

### ì•ˆì •ì„± í–¥ìƒ
- âœ… **ë²„ê·¸ ì œê±°**: ì¹˜ëª…ì ì¸ ë¡œì§ ë²„ê·¸ 5ê°œ ìˆ˜ì •
- âœ… **ë¬´í•œ ë£¨í”„ ë°©ì§€**: ìµœëŒ€ ë°˜ë³µ íšŸìˆ˜ ì œí•œìœ¼ë¡œ ì•ˆì „ì„± í™•ë³´
- âœ… **Null/Undefined ì²˜ë¦¬**: ëª¨ë“  í•¨ìˆ˜ì— ë°©ì–´ì  í”„ë¡œê·¸ë˜ë° ì ìš©

### ì—ëŸ¬ ì²˜ë¦¬ ê°œì„ 
- âœ… **ìƒì„¸í•œ ì—ëŸ¬ ë©”ì‹œì§€**: ë¬¸ì œ ë°œìƒ ì‹œ ì •í™•í•œ ì›ì¸ íŒŒì•… ê°€ëŠ¥
- âœ… **Graceful Degradation**: API ì‹¤íŒ¨ ì‹œ fallback ë©”ì»¤ë‹ˆì¦˜
- âœ… **ë¡œê¹… ê°•í™”**: ë””ë²„ê¹… ë° ëª¨ë‹ˆí„°ë§ ìš©ì´

### íƒ€ì… ì•ˆì „ì„±
- âœ… **ëŸ°íƒ€ì„ ê²€ì¦**: ëª¨ë“  ì…ë ¥ê°’ íƒ€ì… ê²€ì¦
- âœ… **ê²½ê³„ ì¡°ê±´ ì²˜ë¦¬**: ë¹ˆ ë°°ì—´, null, undefined ë“± ëª¨ë“  ì—£ì§€ ì¼€ì´ìŠ¤ ì²˜ë¦¬
- âœ… **ì¼ê´€ì„± ìœ ì§€**: ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥

### ì„±ëŠ¥ ìµœì í™”
- âœ… **API ì¬ì‹œë„ ìµœì í™”**: Exponential backoffë¡œ ë¶ˆí•„ìš”í•œ í˜¸ì¶œ ê°ì†Œ
- âœ… **ë°°ì¹˜ ì²˜ë¦¬**: Rate limiting ìë™ ì¡°ì ˆ
- âœ… **ì¡°ê¸° ì¢…ë£Œ**: ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„° ë¹ ë¥´ê²Œ í•„í„°ë§

---

## ğŸ¯ ê²°ë¡ 

ì´ë²ˆ ê°œì„ ì„ í†µí•´:

1. **í”„ë¡œë•ì…˜ ì¤€ë¹„ ì™„ë£Œ**: ì¹˜ëª…ì ì¸ ë²„ê·¸ ëª¨ë‘ ìˆ˜ì •
2. **ì•ˆì •ì„± ëŒ€í­ í–¥ìƒ**: ì—£ì§€ ì¼€ì´ìŠ¤ ë° ì—ëŸ¬ ì²˜ë¦¬ ì™„ë²½
3. **ìœ ì§€ë³´ìˆ˜ì„± ê°œì„ **: ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€ì™€ ë¡œê¹…
4. **í™•ì¥ ê°€ëŠ¥ì„±**: ê²¬ê³ í•œ ê¸°ë°˜ ìœ„ì— ì¶”ê°€ ê¸°ëŠ¥ ê°œë°œ ê°€ëŠ¥

ëª¨ë“  ìˆ˜ì • ì‚¬í•­ì€ ê¸°ì¡´ APIì™€ ì™„ë²½íˆ í˜¸í™˜ë˜ë©°, ì¶”ê°€ ê¸°ëŠ¥ì„ ì•ˆì „í•˜ê²Œ ê°œë°œí•  ìˆ˜ ìˆëŠ” íŠ¼íŠ¼í•œ ê¸°ë°˜ì„ ì œê³µí•©ë‹ˆë‹¤.
