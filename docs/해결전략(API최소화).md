# 해결 전략(사용자 납득 + API 최소화)

## **“직관적으로 보기 좋은 단일 동선을 먼저 만들고, 
그 동선의 구간 이동시간만 API로 검증한다.”**

---

## ✅ 0) 한 장으로 이해(근거 이미지)

![1231.png](1231.png)

📎 [그림 1] 같은 지도·같은 장소(방문지 동일)에서 ‘동선 선택’만 바뀌는 비교(시간 격차 완화 버전)

**그림 1 해석(근거로서의 포인트)**

- 두 패널은 **같은 지도, 같은 장소 배치(A,B,C,D,E)** 를 전제로 한다.
- 다른 것은 **방문 순서(동선)** 뿐이다(비교 조건 통제).
- 왼쪽은 **형태상 빙글빙글**이지만 더 빠를 수 있고, 오른쪽은 **형태상 더 직관적/깔끔**하지만 약간 더 느릴 수 있다.
- 핵심은 “보기 좋음”이 “시간 최적”과 항상 일치하지 않지만, **시간 손해가 작은 범위(예: +3분)** 에서도 **보기 좋음의 설득력**이 성립한다는 점이다.

---

## ✅ 1) 해결 전략 요약

### 1.1 “좋은 경로”는 항상 “가장 빠른 경로”가 아니다

도보+대중교통 동선에서 사용자는 종종 다음을 더 우선한다.

- **이해가 쉬움**(한눈에 납득)
- **동선이 단순함**(교차/되돌아감/지그재그가 적음)
- **실행이 편함**(환승/대기/헷갈림이 적음)
- **안심됨**(따라가기 쉽고 예측 가능)

→ 따라서 제품 전략은 “최단시간”을 절대 목표로 삼기보다 **‘보기 좋음(직관성)’을 핵심 기준**으로 두는 편이 설득력이 강하다.

---

### 1.2 하지만 “보기 좋음만”으로 끝내면 실패한다(현실 검증 필요)

보기 좋아도 실제로 터무니없이 느리면 신뢰가 깨진다.

문제는 그 검증을 위해 모든 지점쌍을 API로 호출하면 비용/지연이 폭증한다.

> ✅ 결론(핵심 전략)
> 
> 
> **보기 좋은 단일 동선을 먼저 만든다 → 그 동선의 ‘구간’만 API로 검증한다.**
> 
> 전체 행렬을 만들지 않는다.
> 

---

### 1.3 API 최소화가 구조적으로 가능한 이유

지점 n개일 때,

- 전체 지점쌍(i→j) 호출: 대략 **n(n−1)** → **O(n²)**
- 단일 동선 1개의 구간 호출: 대략 **n개 내외** → **O(n)**

---

---

# 2) 핵심 주장

> “본 서비스는 최단시간 최적화보다 사용자의 납득과 실행 가능성을 우선한다.
> 
> 
> 이를 위해 ‘직관적으로 보기 좋은 단일 동선’을 먼저 생성하고, 해당 동선의 구간 이동시간만 API로 검증하여 (1) 사용자 신뢰를 높이고 (2) API 호출을 O(n²)에서 O(n) 수준으로 낮춘다.”
> 

---

---

# 3) “보기 좋은 단일 동선” 생성 로직

> 🎯 목표
> 
> 
> **‘한 방향 흐름’ + ‘교차 최소’ + ‘되돌아감 최소’ + ‘꺾임 최소’**
> 
> → 사용자가 지도에서 봤을 때 “아, 이게 맞지”라고 느끼는 형태를 우선 생성
> 

---

## 3.1 ‘보기 좋음’을 수치화(직관 점수)

아래는 시간 최소가 아니라 **형태/인지적 단순성**을 점수로 만든다.

| 지표 | 의미 | 낮을수록 좋은 이유 |
| --- | --- | --- |
| 꺾임(회전) 페널티 | 방향 변화(각도) 합 | 지그재그가 비효율로 보임 |
| 되돌아감(Backtracking) | 진행 축 역행 정도 | 왔다갔다 느낌이 큼 |
| 교차(Crossing) | 선분 교차 수 | 복잡해 보임 |
| 굴곡도(Curvature) | 전체 곡률 | 흐름이 매끄럽지 않음 |
| 군집 연속성 | 가까운 지점 묶음 방문 | “구역 단위로 처리” 느낌 |

> ✅ 정책 선언
> 
> 
> **우리는 ‘시간’이 아니라 ‘직관 점수’를 최소화한다.**
> 
> 단, “비정상적으로 느린 구간”만 API로 검증해 실패를 방지한다.
> 

---

## 3.2 단일 동선 생성 절차(Simplicity-first: 1-pass + 1회 정돈)

### Step A) 큰 흐름(방향 축)부터 만든다

- 출발점을 기준으로 지점들을 어떤 진행 축에 따라 정렬해 **전체 흐름을 먼저 만든다.**
- 목표는 “한 방향으로 이어지는 느낌(모노토닉한 진행)”이다.

### Step B) 다음 후보를 제한하고, 직관 점수로 “한 개”만 선택한다

- 각 단계에서 다음 후보를 **가까운 k개**(예: 5~10개)로 제한
- 후보 중 **직관 점수(꺾임/교차/되돌아감/군집이탈)**가 최소인 곳을 선택
- 이 과정은 “후보 여러 개 생성”이 아니라 **항상 단일 경로 1개로 수렴**한다.

### Step C) 마지막에 1번만 “형태 정돈(로컬 정돈)”을 한다

- 전체 최적해 탐색이 아니라,
    
    **교차/과도한 꺾임/되돌아감이 발생한 구간만** 국소적으로 정돈한다.
    
- 목적 함수는 “시간 단축”이 아니라 **형태 개선(직관 점수 감소)** 이다.

---

---

# 4) API 검증 설계(옵션 없이, 단일 동선만 검증)

## 4.1 구간만 호출하는 규칙

단일 동선이 `P = (p1→p2→…→pn)` 이면 API는 아래만 호출한다.

- (p1→p2), (p2→p3), …, (p(n−1)→pn)

✅ 호출량: 약 n개

❌ 전체 행렬: n(n−1)개

---

## 4.2 검증의 목적은 “최단시간 달성”이 아니라 “실패 방지”

API 검증은 다음 리스크를 막기 위한 안전장치다.

- 특정 구간이 **비정상적으로 오래 걸림(대기/환승 폭탄)**
- 특정 구간이 **실행 난이도가 높음(환승 과다/도보 연결 과다)**
- 전체 소요가 사용자의 기대에서 **과도하게 벗어남**

---

## 4.3 경고 플래그 규칙(초안)

| 항목 | 임계치(예시) | 처리 |
| --- | --- | --- |
| 구간 소요시간 | 20분 초과 | 경고 플래그 |
| 환승 횟수 | 2회 초과 | 경고 플래그 |
| 대기 추정 | 8분 초과 | 경고 플래그 |
| 전체 소요시간 | 기대 대비 +15% 초과 | 경고 플래그 |

> ✅ 처리 원칙
> 
> 
> 플래그가 켜졌을 때만 **해당 구간 주변을 국소 수정**한다.
> 
> 전체 경로를 다시 만들지 않는다(보기 좋음의 일관성 유지).
> 

---

---

# 5) “동선 2(보기 좋음)”을 지지하는 설득 논리

## 5.1 보기 좋은 경로는 “이해 비용”을 낮춘다

동선이 단순하면 사용자는 “왜 이렇게 가야 하지?”를 덜 묻고, 실행 중 이탈/불신/재탐색이 줄어 신뢰가 올라간다.

## 5.2 보기 좋은 경로는 “실행 가능성”을 높인다

현실 이동에서 실패 요인은 최단시간 미달보다 “헷갈림/피로/환승 스트레스”에서 많이 생긴다.

보기 좋은 동선은 이 리스크를 줄이는 방향과 정렬된다.

## 5.3 시간 손해는 ‘작게 관리’할 수 있다(운영 포인트)

“보기 좋음”을 채택하더라도 **시간 격차를 작은 범위(예: +3분, +10~15%)**로 관리하면

동선 2의 설득력은 유지되면서 부담은 줄어든다.

(그림 1은 그 전략을 반영한 사례다.)

---

---

# 6) 구현/운영 체크리스트(노션용)

- [ ]  동선 생성 목적함수는 “직관 점수”다(시간 최소 아님)
- [ ]  생성은 단일 동선 1개만 만든다(옵션 제공 없음)
- [ ]  API는 전체 행렬이 아니라 “동선 구간”만 호출한다
- [ ]  API 검증은 “최적화”가 아니라 “실패 방지”다
- [ ]  경고 플래그 발생 시에만 “국소 수정”한다
- [ ]  근거 제시는 “시간 격차가 작은 사례”를 기본으로 한다

---

---

# 7) (토글) 추가 고도화 항목

- 초행/여행자: 교차/꺾임 페널티↑
- 대중교통 민감: 되돌아감↓ + 경고 플래그 강화
- 구역 방문 선호: 군집 연속성↑
- 교차 없음
- 되돌아감 적음
- 흐름 단순(한 방향 진행)
- 구역 단위 방문

---

---

# 8) 레퍼런스/근거 섹션(형식)

- 경로 시각화에서의 인지 부담 관련 자료
- 미적-사용성(보기 좋음이 신뢰에 미치는 영향) 관련 자료
- 추천/경로 제시에서 설명(근거 제시)이 신뢰에 미치는 영향 관련 자료

---