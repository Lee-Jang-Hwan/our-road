# 대중교통 알고리즘 구역 분할 문제 분석

## 문제 상황

### 현상

비슷한 구역의 장소들이 다음날로 나뉘어 배치되어 불필요한 경로가 생성됩니다.

**예시:**

- **입력**: 1박2일, A구역 4곳, B구역 2곳
- **현재 결과**:
  - 1일차: A구역 2곳 + B구역 1곳
  - 2일차: A구역 1곳 + B구역 2곳
- **기대 결과**:
  - 1일차: A구역 4곳
  - 2일차: B구역 2곳

### 문제의 심각성

- 같은 구역 내 장소들이 다른 날로 분산되어 불필요한 구역 간 이동 발생
- 대중교통 특성상 구역 간 이동은 시간이 오래 걸리고 환승이 필요할 수 있음
- 사용자 경험 저하: "왜 같은 지역을 두 번 왔다갔다 하나?"

---

## 알고리즘 흐름 분석

### 전체 프로세스

```
입력 (경유지, 일수)
  ↓
[1단계] 클러스터링 (balancedClustering)
  ├─ 시드 선택 (selectDistributedSeeds)
  ├─ 경유지 할당 (findNearestCluster)
  └─ 균형화 (balanceClusterSizes)
  ↓
[2단계] 구역 간 순서 결정
  ↓
[3단계] 구역 내 순서 결정
  ↓
출력 (일자별 경로)
```

**핵심 문제는 1단계 클러스터링에서 발생합니다.**

---

## 1단계: 클러스터링 상세 분석

### 1.1 시드 선택 (selectDistributedSeeds)

**목적**: N일(클러스터 개수)에 맞춰 멀리 떨어진 대표점을 선택

**과정**:

1. 전체 경유지의 중심점(centroid) 계산
2. 중심점에서 가장 먼 경유지를 첫 번째 시드로 선택
3. 이미 선택된 시드들에서 가장 먼 경유지를 다음 시드로 선택
4. N개의 시드가 선택될 때까지 반복

**문제점**:

- **공간적 분산만 고려**: 멀리 떨어진 점을 선택하므로, A구역과 B구역에서 각각 시드가 선택될 수 있음
- **구역 내 밀도 무시**: A구역에 4곳, B구역에 2곳이 있어도 각 구역에서 시드가 선택됨
- **결과**: A구역 시드 1개, B구역 시드 1개가 선택됨

---

### 1.2 경유지 할당 (findNearestCluster)

**목적**: 각 경유지를 가장 가까운 시드의 클러스터에 할당

**과정**:

1. 각 경유지에 대해 모든 클러스터와의 거리 계산
2. 가장 가까운 클러스터 선택
3. **용량 제한 확인**: `targetPerDay` (일자당 평균 경유지 수)를 초과하지 않는지 확인
4. 용량이 남아있으면 할당, 없으면 다음 가까운 클러스터 선택

**핵심 로직**:

```
targetPerDay = ceil(총 경유지 수 / 일수)
예: 6개 경유지 / 2일 = 3개

각 경유지 할당 시:
  if (가장 가까운 클러스터.용량 < targetPerDay) {
    할당
  } else {
    다음 가까운 클러스터 확인
  }
```

**문제 발생 시나리오**:

**시나리오 1: 용량 제한으로 인한 강제 이동**

- A구역 시드 클러스터에 A구역 경유지 3개가 먼저 할당됨 (targetPerDay = 3)
- A구역의 4번째 경유지가 할당될 때, A 클러스터는 용량 초과
- B 클러스터가 더 가까울 수도 있지만, 보통은 A 클러스터가 더 가까움
- 하지만 용량 제한 때문에 B 클러스터에 할당될 수 있음

**시나리오 2: 거리 기반 할당의 한계**

- A구역과 B구역이 가까운 경우, A구역의 일부 경유지가 B구역 시드에 더 가까울 수 있음
- 공간적으로는 합리적이지만, 구역 단위로 묶이는 것이 더 효율적일 수 있음

---

### 1.3 균형화 (balanceClusterSizes)

**목적**: 클러스터 크기를 균등하게 맞춤

**과정**:

1. 클러스터를 크기 순으로 정렬
2. 가장 큰 클러스터와 가장 작은 클러스터 비교
3. 크기 차이가 1 이하이면 종료
4. 가장 큰 클러스터에서 가장 작은 클러스터로 경유지 이동
5. 이동 조건:
   - 이동 가능한 경유지 (시드, 고정 일정 제외)
   - 가장 작은 클러스터의 중심에 가장 가까운 경유지
   - 단, 현재 클러스터보다 3배 이상 멀면 이동하지 않음

**문제점**:

- **균등 분배 우선**: 공간적 응집도보다 일자별 균등 분배를 우선시
- **이동 제한 조건의 한계**: 3배 거리 제한이 있지만, A구역과 B구역이 가까우면 이동이 발생할 수 있음
- **결과**: A구역의 일부 경유지가 B 클러스터로 이동하여 구역이 분산됨

---

## 문제 발생 메커니즘

### 단계별 문제 발생 과정

**예시: 1박2일, A구역 4곳, B구역 2곳**

#### Step 1: 시드 선택

- 전체 경유지 중심점 계산
- 중심점에서 가장 먼 경유지 선택 → A구역의 한 곳
- 이미 선택된 시드에서 가장 먼 경유지 선택 → B구역의 한 곳
- **결과**: A구역 시드 1개, B구역 시드 1개

#### Step 2: 경유지 할당

- `targetPerDay = ceil(6 / 2) = 3`
- A구역 경유지 3개 → A 클러스터 할당 (용량 3/3)
- A구역 경유지 1개 → A 클러스터 용량 초과, B 클러스터에 할당
- B구역 경유지 2개 → B 클러스터 할당
- **결과**: A 클러스터 [A1, A2, A3], B 클러스터 [A4, B1, B2]

#### Step 3: 균형화

- A 클러스터: 3개, B 클러스터: 3개 → 이미 균등
- 추가 이동 없음
- **최종 결과**: 1일차 [A1, A2, A3], 2일차 [A4, B1, B2]

---

## 근본 원인

### 1. 이중 목표의 충돌

알고리즘이 동시에 추구하는 두 목표가 충돌합니다:

**목표 1: 공간적 응집도 최대화**

- 같은 구역의 경유지들을 같은 클러스터에 묶기
- 구역 간 이동 최소화

**목표 2: 일자별 균등 분배**

- 각 일자에 비슷한 수의 경유지 배정
- `targetPerDay` 기준으로 용량 제한

**충돌 상황**:

- A구역에 4곳, B구역에 2곳인 경우
- 공간적 응집도 우선: 1일차 [A 4곳], 2일차 [B 2곳] (불균등)
- 균등 분배 우선: 1일차 [A 3곳], 2일차 [A 1곳, B 2곳] (구역 분산)

**현재 알고리즘**: 균등 분배를 우선시하여 구역이 분산됨

---

### 2. 시드 선택 방식의 한계

**현재 방식**: 멀리 떨어진 점을 선택 (Max-Min 방식)

**문제점**:

- 구역의 밀도나 크기를 고려하지 않음
- A구역에 4곳, B구역에 2곳이어도 각 구역에서 시드가 선택됨
- 구역 단위로 묶는 것이 더 효율적이어도, 시드가 각 구역에 하나씩 있으면 구역이 분산될 수 있음

**개선 방향**:

- 밀도 기반 시드 선택 (경유지가 많이 모인 구역 우선)
- 구역 인식 후 구역 단위로 클러스터링

---

### 3. 용량 제한의 경직성

**현재 방식**: `targetPerDay`를 엄격한 용량 제한으로 사용

**문제점**:

- A구역에 4곳이 있어도, `targetPerDay = 3`이면 1곳이 다른 클러스터로 이동
- 유연성 범위(`flexibilityRange = 0.4`)가 있지만, 균형화 단계에서만 적용
- 할당 단계에서는 엄격한 용량 제한 적용

**개선 방향**:

- 공간적 응집도가 높으면 용량 제한을 완화
- 구역 단위로 묶을 때는 불균등 분배 허용

---

### 4. 균형화의 공간 무시

**현재 방식**: 크기만 고려하여 균등화

**문제점**:

- 공간적 응집도를 고려하지 않고 크기만 맞춤
- A구역의 경유지가 B 클러스터로 이동해도, 거리 제한(3배) 내이면 이동 허용
- 구역 단위 응집도 손실

**개선 방향**:

- 균형화 시 공간적 응집도 손실 비용 계산
- 응집도 손실이 크면 균형화 포기

---

## 왜 이런 설계가 되었나?

### 설계 의도

1. **일자별 균등 분배**: 각 날에 비슷한 수의 장소를 방문하여 일정이 균형잡히도록
2. **공간적 응집도**: 가까운 곳끼리 묶어 이동 시간 최소화
3. **API 호출 최소화**: 구역 단위로 묶어 O(n) 호출 유지

### 설계의 한계

**균등 분배와 공간적 응집도 사이의 트레이드오프를 제대로 처리하지 못함**

- 균등 분배를 우선시하면 → 구역 분산 발생
- 공간적 응집도를 우선시하면 → 일자별 불균등 발생

**현재는 균등 분배가 우선**되어 구역 분산 문제가 발생합니다.

---

## 해결 방향 제안

### 방향 1: 공간적 응집도 우선 (권장)

**원칙**: 같은 구역의 경유지는 같은 일자에 배정

**구현**:

1. 구역 인식: 밀도 기반 클러스터링으로 구역 자동 인식
2. 구역 단위 할당: 구역 전체를 하나의 단위로 취급
3. 구역 간 균등 분배: 구역 단위로 일자에 배정

**장점**:

- 구역 분산 문제 해결
- 현실적인 경로 생성

**단점**:

- 일자별 불균등 발생 가능 (예: 1일차 4곳, 2일차 2곳)

---

### 방향 2: 가중치 기반 균형

**원칙**: 공간적 응집도와 균등 분배를 가중치로 조절

**구현**:

1. 응집도 점수 계산: 같은 구역 내 경유지 비율
2. 균등 분배 점수 계산: 일자별 경유지 수의 표준편차
3. 가중합 최적화: `w1 × 응집도 + w2 × 균등분배` 최대화

**장점**:

- 두 목표를 모두 고려
- 사용자 설정으로 조절 가능

**단점**:

- 복잡도 증가
- 가중치 튜닝 필요

---

### 방향 3: 2단계 클러스터링

**원칙**: 먼저 구역 단위로 묶고, 그 다음 일자별로 분배

**구현**:

1. 1단계: 밀도 기반 클러스터링으로 구역 인식 (일수 무관)
2. 2단계: 구역 단위로 일자에 배정 (균등 분배 시도)

**장점**:

- 구역 응집도 보장
- 단계별 최적화로 이해하기 쉬움

**단점**:

- 구역 크기가 극단적이면 여전히 불균등 발생

---

## 결론

### 현재 문제의 핵심

**균등 분배 우선 정책**으로 인해 **공간적 응집도가 희생**되고 있습니다.

### 해결 필요성

대중교통 특성상 구역 간 이동은 시간이 오래 걸리고 환승이 필요하므로, **공간적 응집도를 우선시**하는 것이 더 합리적입니다.

### 권장 해결책

**방향 1 (공간적 응집도 우선)**을 권장합니다:

- 구역 단위로 묶는 것을 최우선으로
- 일자별 불균등은 허용 (사용자가 이해할 수 있는 수준)
- 필요시 시간 제한으로 일부 경유지 제외

이렇게 하면 "1일차에 A구역 4곳, 2일차에 B구역 2곳"과 같은 현실적인 경로가 생성됩니다.
