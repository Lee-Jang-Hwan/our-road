# 📍 [기획/설계] 경로 최적화 : 가중치 기반 경유지 제외 로직

---

## 1. 개요 (Overview)

사용자가 선택한 경로가 **하루 제한 시간(또는 거리)을 초과**했을 때, 전체 동선을 다시 짜는 것이 아니라 **'가장 비효율적이면서 덜 중요한'** 경유지를 선별하여 제거하는 로직입니다.

### 🎯 핵심 목표

1. **고정 경유지 보존:** 사용자가 고정한 장소(`Fixed`)는 절대 건드리지 않는다.
2. **동선 효율화:** 동선을 꼬이게 하거나(Backtracking), 과도하게 돌아가는(Detour) 지점을 우선 제거한다.
3. **사용자 선호 반영:** 사용자가 중요하다고 설정했거나 체류 시간이 긴 장소는 최대한 살린다.

---

## 2. 데이터 구조 및 파라미터

### 2.1 경유지 속성 (Waypoint Attributes)

각 경유지 객체(`Node`)는 아래 속성을 반드시 가져야 합니다.

| **속성 (Variable)** | **타입** | **설명** | **비고** |
| --- | --- | --- | --- |
| `id` | String | 고유 식별자 |  |
| `type` | Enum | `FIXED` (고정), `DAY_LOCK` (일자 고정), `NORMAL` (일반) | **제거 후보는 `NORMAL` 뿐임** |
| `importance` | Int | 사용자 중요도 (1 ~ 5) | 클수록 제거 확률 ↓ |
| `stayTime` | Int | 체류 시간 (분) | 클수록 제거 확률 ↓ |
| `location` | Geo | 위도, 경도 | 거리/시간 계산용 |

### 2.2 가중치 상수 (Weight Constants)

튜닝이 가능한 상수로 관리합니다. (초기값 제안)

```jsx
const WEIGHTS = {
  ALPHA_BACKTRACKing: 2.0, // 되돌아감 페널티 (동선 꼬임)
  BETA_CROSSING:      1.0, // 교차 발생 페널티
  GAMMA_TIME:         1.0, // 시간 증가 페널티
  DELTA_DISTANCE:     0.5, // 거리 증가 페널티
  EPSILON_IMPORTANCE: 2.0, // 중요도 보너스 (보존 가중치)
  ZETA_STAYTIME:      1.0  // 체류시간 보너스 (보존 가중치)
};
```

---

## 3. 핵심 로직 (Algorithm Logic)

### 3.1 전체 프로세스 흐름도

> While (총 소요시간 > 하루 제한 시간) Do:
> 
> 1. 현재 경로에서 `FIXED`, `DAY_LOCK`을 제외한 `NORMAL` 노드 리스트 추출
> 2. 후보 노드가 없으면 루프 중단 (최적화 실패 or 사용자 알림)
> 3. 각 후보 노드에 대해 `CalculateRemovalScore()` 실행
> 4. **점수가 가장 높은(Remove Priority)** 노드 1개 삭제
> 5. 경로 재연결 및 총 시간/거리 다시 계산

### 3.2 점수 계산 공식 (Scoring Formula)

점수가 **높을수록** 제거 1순위입니다.

$$Score = (Penalty_{movement}) - (Bonus_{value})$$

### 상세 구현 수식

$$Score = (\alpha \times Backtracking) + (\beta \times Crossing) + (\gamma \times \Delta Time) + (\delta \times \Delta Dist) - (\epsilon \times Importance) - (\zeta \times StayTime)$$

---

## 4. 구현 상세 (Implementation Detail)

### 4.1 의사 코드 (Pseudocode)

```python
def optimize_route(route, max_daily_time):
    current_time = calculate_total_time(route)
    
    # 제약 조건 만족할 때까지 반복
    while current_time > max_daily_time:
        
        candidates = [] # 제거 가능한 후보군 (Normal type)
        
        # 1. 후보군 선별
        for node in route.nodes:
            if node.type == 'NORMAL':
                candidates.append(node)
        
        if not candidates:
            break # 더 이상 뺄 게 없음 (실패 처리)

        # 2. 각 후보의 제거 점수 계산
        best_candidate_to_remove = None
        max_score = -Infinity

        for node in candidates:
            # 점수 계산 함수 (아래 4.2 참조)
            score = calculate_removal_score(node, route, WEIGHTS)
            
            if score > max_score:
                max_score = score
                best_candidate_to_remove = node
        
        # 3. 점수가 가장 높은 노드 삭제
        route.remove(best_candidate_to_remove)
        
        # 4. 시간 재계산 (API 호출 혹은 직선거리 근사치)
        current_time = calculate_total_time(route)

    return route
```

### 4.2 각 항목별 계산 방법 (Calculations)

### A. 동선 페널티 ($\Delta Time, \Delta Dist$)

- **정의:** 이 노드가 *있을 때*와 *없을 때*의 전체 경로 비용 차이 (Marginal Cost)
- **계산:**
    - `Prev` -> `Target` -> `Next` 연결 상태
    - **Cost(Include):** `Dist(Prev, Target) + Dist(Target, Next)`
    - **Cost(Exclude):** `Dist(Prev, Next)`
    - **Delta:** `Cost(Include) - Cost(Exclude)`
    - *값이 클수록 이 점 때문에 낭비되는 거리/시간이 많다는 뜻.*

### B. 되돌아감 (Backtracking Delta)

- **정의:** 진행 방향이 급격히 꺾여서 왔던 길을 되돌아가는 현상 감지
- **계산 (벡터 내적 활용):**
    - 벡터 A: `Prev` -> `Target`
    - 벡터 B: `Target` -> `Next`
    - 두 벡터 사이의 각도($\theta$)를 계산.
    - 각도가 180도에 가까울수록(예각) 되돌아가는 것.
    - `Value`: $cos(\theta)$ 값이 -1에 가까울수록 페널티 부여.

### C. 교차 증가 (Crossing Delta)

- **정의:** 경로 선분이 서로 겹치는(X자) 횟수 증가량
- **계산:**
    - 현재 경로의 총 교차 횟수 vs 해당 노드를 뺐을 때의 총 교차 횟수 비교.
    - (구현 복잡도가 높으므로 초기엔 제외하거나 간소화 가능)

---

## 5. 고려사항 및 예외처리 (Edge Cases)

### 💡 API 비용 및 성능 이슈

- **문제:** 루프를 돌 때마다 Google Maps/Tmap API로 정확한 시간을 다시 계산하면 비용과 대기시간이 폭증함.
- **해결:**
    - 제거 로직 내부에서는 **직선 거리(Haversine)** 기반으로 빠르게 점수를 계산하여 후보를 선정.
    - 최종 결정된 세트에 대해서만 실제 경로 API를 호출하는 방식 권장.

### 💡 중요도 밸런싱

- **문제:** 중요도가 5점인 곳이 너무 먼 곳에 있어서 전체 일정을 망치는 경우.
- **해결:** 가중치 $\epsilon$(중요도) 값을 조절해야 함. 만약 중요도가 높아도 동선 파괴가 심각하면 제거되어야 한다면 $\alpha, \gamma$ 비율을 높임.

### 💡 남은 후보가 없을 때

- `FIXED`와 `DAY_LOCK` 만으로도 이미 시간이 초과된 경우.
- **Action:** 사용자에게 "고정된 일정이 너무 많아 최적화할 수 없습니다. 고정을 해제하거나 시간을 늘려주세요"라는 메시지 출력.

---

## 6. 테스트 시나리오 (Test Cases)

1. **동선 효율성 테스트:** A-B-C-D 순서에서 C가 뜬금없이 먼 곳일 때, C가 먼저 삭제되는가?
2. **중요도 방어 테스트:** C가 멀리 있지만 `Importance=5`, D는 가깝지만 `Importance=1`일 때, D가 먼저 삭제되는가?
3. **고정 유지 테스트:** `isFixed=True`인 노드는 점수가 아무리 나빠도 끝까지 살아남는가?