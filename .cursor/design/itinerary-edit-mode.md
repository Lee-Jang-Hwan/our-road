# 일정 편집 모드 화면 설계

## 개요

최적화된 일정 결과 화면에서 드래그 앤 드롭으로 일정을 재배치할 수 있는 편집 모드를 추가합니다. 플레이리스트처럼 직관적으로 장소 순서를 변경하고, 일차 간 이동도 가능합니다. 모든 변경사항은 자동으로 저장되어 별도의 저장 버튼이 필요 없습니다.

## 화면 구조

### 1. 편집 모드 토글

**위치**: `/my/trips/[tripId]` 페이지 헤더 영역

```
┌─────────────────────────────────────────┐
│ ← [여행 제목]                    [편집 모드] │
│   2025-01-20 ~ 2025-01-22               │
└─────────────────────────────────────────┘
```

- **읽기 모드**: "편집 모드" 버튼 표시
- **편집 모드**: "완료" / "취소" 버튼 표시
- 편집 모드 진입 시 하단 버튼 영역 변경

### 2. 편집 모드 UI 레이아웃

#### 2-1. 전체 일정 세로 나열 (스크롤 가능)

**핵심**: 모든 일차의 일정이 한 화면에 세로로 쭉 나열되어 드래그 앤 드롭으로 일차 간 이동이 쉽게 가능

```
┌─────────────────────────────────────────┐
│ 📅 1일차 (2025-01-20 월요일)             │ ← 일차 헤더 (드래그 불가, 스크롤과 함께 이동)
├─────────────────────────────────────────┤
│                                          │
│  📍 출발지 (09:00)                       │
│  └─ 이동 (10분)                          │
│  📍 장소1 (09:10)                        │ ← 드래그 가능
│  └─ 이동 (15분)                          │
│  📍 장소2 (09:25)                        │ ← 드래그 가능
│  └─ 이동 (20분)                          │
│  📍 장소3 (09:45)                        │ ← 드래그 가능
│  └─ 이동 (30분)                          │
│  🏠 숙소 (10:15)                         │
│                                          │
├─────────────────────────────────────────┤
│ 📅 2일차 (2025-01-21 화요일)             │ ← 일차 헤더 (드래그 불가, 스크롤과 함께 이동)
├─────────────────────────────────────────┤
│                                          │
│  🏠 숙소 (09:00)                         │
│  └─ 이동 (10분)                          │
│  📍 장소4 (09:10)                        │ ← 드래그 가능
│  └─ 이동 (15분)                          │
│  📍 장소5 (09:25)                        │ ← 드래그 가능
│  └─ 이동 (20분)                          │
│  🏠 숙소 (09:45)                         │
│                                          │
├─────────────────────────────────────────┤
│ 📅 3일차 (2025-01-22 수요일)             │ ← 일차 헤더 (드래그 불가, 스크롤과 함께 이동)
├─────────────────────────────────────────┤
│                                          │
│  🏠 숙소 (09:00)                         │
│  └─ 이동 (10분)                          │
│  📍 장소6 (09:10)                        │ ← 드래그 가능
│  └─ 이동 (15분)                          │
│  📍 장소7 (09:25)                        │ ← 드래그 가능
│  └─ 이동 (20분)                          │
│  📍 도착지 (09:45)                       │
│                                          │
└─────────────────────────────────────────┘
         ↑ 스크롤 가능
```

#### 2-2. 드래그 중 시각적 피드백

드래그 중일 때 드롭 가능한 위치에 하이라이트 표시:

```
┌─────────────────────────────────────────┐
│ 📅 1일차 (2025-01-20 월요일)             │
├─────────────────────────────────────────┤
│  📍 장소1 (09:10)                        │
│  └─ 이동 (15분)                          │
│  ┌─────────────────────────────────┐    │ ← 드롭 존 (하이라이트)
│  │  여기에 놓으면 장소2 앞에 삽입    │    │
│  └─────────────────────────────────┘    │
│  📍 장소2 (09:25)                        │
│  └─ 이동 (20분)                          │
│  📍 장소3 (09:45)                        │
│                                          │
├─────────────────────────────────────────┤
│ 📅 2일차 (2025-01-21 화요일)             │
├─────────────────────────────────────────┤
│  ┌─────────────────────────────────┐    │ ← 드롭 존 (다른 일차)
│  │  여기에 놓으면 2일차로 이동        │    │
│  └─────────────────────────────────┘    │
│  📍 장소4 (09:10)                        │
│                                          │
└─────────────────────────────────────────┘
```

### 3. 드래그 앤 드롭 인터랙션

#### 3-1. 드래그 시작

- 장소 항목을 길게 누르거나 드래그 시작
- 드래그 중인 항목:
  - 반투명 처리 (opacity: 0.5)
  - 그림자 효과
  - 원래 위치에 플레이스홀더 표시 (회색 점선 박스)

#### 3-2. 드래그 중

- 스크롤 가능한 영역에서 자동 스크롤 (드래그가 화면 끝에 가까우면)
- 드롭 가능한 위치에 하이라이트 표시 (회색 점선 박스)
- 같은 일차 내: 순서 변경 (위치 표시)
- 다른 일차: 일차 헤더 아래 또는 특정 장소 사이에 삽입 가능

#### 3-3. 드롭

- 같은 일차 내: 선택한 위치에 삽입 (순서 변경)
- 다른 일차: 선택한 위치에 삽입
  - 일차 헤더 바로 아래: 해당 일차의 첫 번째 장소
  - 장소 사이: 해당 위치에 삽입
  - 일차 끝: 해당 일차의 마지막 장소

### 4. 하단 버튼 영역

#### 읽기 모드

```
┌─────────────────────────────────────────┐
│ [편집하기] [네비게이션]                  │
└─────────────────────────────────────────┘
```

#### 편집 모드

```
┌─────────────────────────────────────────┐
│ [편집 종료] [경로 재계산]                 │
└─────────────────────────────────────────┘
```

- **편집 종료**: 편집 모드를 종료하고 읽기 모드로 (변경사항은 이미 자동 저장됨)
- **경로 재계산**: 순서는 유지하고 실제 API로 경로/시간/거리 정보만 다시 조회
  - 로딩 중 표시
  - 각 구간별 API 호출 (시간 소요)
  - 완료 후 시간 자동 재계산 및 자동 저장

## 편집 모드 기능

### 1. 장소 관리

**장소 삭제**:

- 각 장소 항목에 삭제 버튼 표시 (편집 모드에서만)
- 삭제 시 확인 다이얼로그
- 삭제 후 자동 저장

**장소 추가** (선택적):

- 편집 모드에서도 새 장소를 추가할 수 있는 기능
- "장소 추가" 버튼 또는 플로팅 버튼
- 장소 추가 후 해당 일차의 끝에 자동 배치 (또는 사용자가 위치 선택)
- 추가 후 자동 저장

**체류 시간 변경**:

- 각 장소의 체류 시간을 편집 모드에서 직접 수정 가능
- 변경 시 시간 재계산 및 자동 저장

### 2. 시간 재계산 로직

**핵심 원칙**: 기존 경로 정보를 최대한 재사용. 동일한 구간은 기존 정보 그대로 사용하고, 새로 생긴 구간만 API 호출. 근사치는 사용하지 않음.

#### 2-1. 순서 변경 시 자동 시간 재계산

사용자가 드래그 앤 드롭으로 순서를 변경하면 즉시 시간이 재계산됩니다. 이 과정에서는 기존에 저장된 경로 정보를 재사용합니다.

**이동 수단별 재사용 전략**:

##### 차량 모드 (Car Mode)

**특징**:

- 최적화 시 모든 장소 쌍에 대해 병렬로 API를 호출해서 거리 행렬(DistanceMatrix)을 생성
- 거리 행렬에는 모든 장소 쌍의 경로 정보가 포함됨 (A→B, A→C, B→C 등)
- 차량 경로는 시간대와 무관하게 일정함

**재사용 전략**:

1. **순서만 변경하거나 장소 삭제하는 경우**:

   - 거리 행렬에서 모든 구간 정보를 즉시 조회 가능 ✅
   - **API 호출 불필요**
   - 예: A → B → C에서 A → C → B로 변경
     - A→C: 거리 행렬에서 조회 ✅
     - C→B: 거리 행렬에서 조회 ✅
     - → API 호출 0회, 즉시 완료

2. **새 장소를 추가하는 경우**:
   - 새로 생긴 구간만 API 호출 필요 ⚠️
   - 예: A → B → C에서 A와 B 사이에 X 추가 → A → X → B → C
     - A→X: 새 구간 → API 호출 필요 ⚠️
     - X→B: 새 구간 → API 호출 필요 ⚠️
     - B→C: 기존 구간 → 거리 행렬에서 조회 ✅
     - → 총 2개 구간만 API 호출

**시간 재계산 프로세스**:

1. 순서 변경 감지
2. 각 구간별로 거리 행렬에서 정보 조회
3. 있으면: 그 정보 사용 (정확함) ✅
4. 없으면: 해당 구간만 API 호출 ⚠️
5. 도착 시간 = 이전 장소 출발 시간 + 이동 시간
6. 출발 시간 = 도착 시간 + 체류 시간

##### 대중교통 모드 (Public Transit Mode)

**특징**:

- 최적화 시 각 구간의 경로 정보(`transportToNext`)가 `trip_itineraries` 테이블에 저장됨
- 저장된 정보: `duration`(소요 시간), `distance`, `polyline`, `transitDetails` 등
- **핵심**: 우리는 "걸리는 시간" 정보를 활용하는 것. 몇 시 기준으로 API를 호출하는 게 아님
- 대중교통 API 한정량이 차량에 비해 적기 때문에, 시간 관계없이 동일한 구간은 기존 정보 재사용

**재사용 전략**:

1. **동일한 구간은 시간 관계없이 재사용**:

   - 기존 일정에서 사용된 구간 정보 확인
   - 경로가 같으면 (A→B), 출발 시간이 미뤄져도 기존 정보 재사용 ✅
   - 예: A→B가 1시간 걸려서 10:00~11:00 이동
     - A 전에 경로가 추가되어 A에서 B로 가는 출발 시간이 2시간 미뤄져서 12:00 출발
     - 기존 정보(1시간 소요)를 활용해서 최종 시간만 2시간 미루기: 12:00~13:00
     - 경로 정보(`transitDetails`, `polyline` 등)는 그대로 사용

2. **새로 변경된 구간만 API 호출**:

   - 순서 변경으로 새로 생긴 구간만 API 호출 필요 ⚠️
   - 예: A → B → C에서 A → C → B로 변경
     - A→C: 새 구간 → API 호출 필요 ⚠️
     - C→B: 새 구간 → API 호출 필요 ⚠️
     - (기존에 A→C, C→B 구간이 없었다면)

3. **새 장소 추가 시**:
   - 새로 생긴 구간만 API 호출 필요 ⚠️
   - 예: A → B → C에서 A와 B 사이에 X 추가 → A → X → B → C
     - A→X: 새 구간 → API 호출 필요 ⚠️
     - X→B: 새 구간 → API 호출 필요 ⚠️
     - B→C: 기존 구간 → 기존 정보 재사용 ✅

**시간 재계산 프로세스**:

1. 순서 변경 감지
2. 각 구간별로 기존 저장된 경로 정보 검색 (`trip_itineraries` 테이블)
3. 동일한 구간이 있으면: 기존 정보 재사용 (시간만 조정) ✅
4. 새 구간이면: 해당 구간만 API 호출 ⚠️
5. 도착 시간 = 이전 장소 출발 시간 + 이동 시간 (기존 정보 또는 새로 조회한 정보)
6. 출발 시간 = 도착 시간 + 체류 시간

#### 2-2. 경로 재계산 (실제 API 호출)

사용자가 "경로 재계산" 버튼을 클릭하면, 순서는 유지한 채 실제 경로 정보만 다시 조회합니다.

**⚠️ 중요**: 최적화 알고리즘을 다시 실행하는 것이 아님. 순서는 유지하고 경로 정보만 업데이트.

**프로세스** (이동 수단별):

##### 차량 모드

1. 현재 편집된 순서 확인 (사용자가 변경한 순서 그대로 유지)
2. 거리 행렬 확인 (최적화 시 생성된 거리 행렬)
3. 재사용 가능 여부 판단:
   - **순서만 변경/장소 삭제**: 거리 행렬에서 조회 (API 호출 0회) ✅
   - **새 장소 추가**: 새로 생긴 구간만 API 호출 ⚠️
4. 필요한 구간만 API 호출 (Kakao Mobility API)
5. 거리 행렬 업데이트 (새로 조회한 경로 정보 추가)
6. 조회된 정보로 `transportToNext` 업데이트
7. 시간 재계산 (실제 이동 시간 반영)
8. 일과 시간 범위 검증
9. 자동 DB 저장

##### 대중교통 모드

1. 현재 편집된 순서 확인 (사용자가 변경한 순서 그대로 유지)
2. 각 구간별 재사용 가능 여부 판단:
   - 기존 저장된 경로 정보 확인 (`trip_itineraries` 테이블)
   - 동일한 구간이 있는지 확인 (시간 관계없이)
   - **판단 기준**:
     - 동일한 구간 (A→B): 기존 정보 재사용, 시간만 조정 ✅
     - 새로 생긴 구간: API 호출 필요 ⚠️
3. 필요한 구간만 실제 경로 API 호출 (ODsay API)
4. 조회된 정보로 `transportToNext` 업데이트
5. 시간 재계산:
   - 기존 정보 재사용 구간: 시간만 조정 (소요 시간은 그대로)
   - 새로 조회한 구간: 실제 이동 시간 반영
6. 일과 시간 범위 검증
7. 자동 DB 저장

**조회되는 정보**:

- 이동 시간 (`duration`)
- 이동 거리 (`distance`)
- 경로 폴리라인 (`polyline`)
- 대중교통 상세 정보 (`transitDetails`) - 대중교통 모드인 경우

**성능 비교**:

| 시나리오     | 차량 모드                       | 대중교통 모드                            |
| ------------ | ------------------------------- | ---------------------------------------- |
| 순서만 변경  | API 호출 0회 (거리 행렬 재사용) | 동일한 구간은 재사용, 새 구간만 API 호출 |
| 장소 삭제    | API 호출 0회 (거리 행렬 재사용) | 동일한 구간은 재사용, 새 구간만 API 호출 |
| 새 장소 추가 | 새로 생긴 구간만 API 호출       | 새로 생긴 구간만 API 호출                |

**⚠️ 주의사항**:

- 최적화 알고리즘을 다시 돌리면 사용자가 정한 순서가 무시됨
- 따라서 "경로 재계산"은 순서는 그대로 두고 경로 정보만 업데이트
- 만약 순서도 다시 최적화하고 싶다면 "일정 최적화하기" 버튼을 다시 눌러야 함 (편집 모드 종료 후)

### 3. 자동 저장

**핵심**: 사용자가 순서를 변경할 때마다 자동으로 저장. 별도의 저장 버튼 불필요.

**트리거**:

- 장소 순서 변경 (드래그 앤 드롭 완료 시)
- 장소 삭제 시
- 일차 간 이동 시
- 장소 추가 시 (편집 모드에서 새 장소 추가)
- 체류 시간 변경 시 (장소의 체류 시간 수정)
- 고정 일정 추가/수정/삭제 시 (편집 모드에서 고정 일정 관리)

**Debounce 적용**:

- 연속된 변경사항이 있을 때 마지막 변경 후 500ms 후에 저장
- 불필요한 저장 요청 최소화

**프로세스**:

1. 변경사항 감지

   - 순서 변경 완료 시 자동 저장 트리거
   - Debounce 타이머 시작

2. 변경사항 검증

   - 일차별 최소 1개 장소 확인 (장소 삭제 시)
   - 고정 일정 시간 충돌 확인
   - 일과 시간 범위 확인
   - 새로 추가된 장소의 유효성 검증 (장소 추가 시)

3. 데이터 변환

   - 편집된 순서 → `DailyItinerary` 형식
   - 시간 재계산 (기존 이동 시간 데이터 사용)
   - `order` 필드 업데이트

4. DB 저장

   - `trip_itineraries` 테이블 업데이트
   - `schedule` 배열 재구성
   - 백그라운드에서 비동기 처리

5. 상태 업데이트

   - `status`: `optimized` → `optimized` (유지)
   - 사용자가 수동으로 편집했음을 표시 (선택적: `isManuallyEdited` 플래그)

6. UI 피드백
   - 저장 중: "저장 중..." 표시
   - 저장 완료: "저장됨" 표시 (2초 후 사라짐)
   - 저장 실패: 에러 토스트 표시

## 컴포넌트 구조

### 새로운 컴포넌트

1. **`ItineraryEditMode`**

   - 편집 모드 상태 관리
   - 드래그 앤 드롭 로직
   - 저장/취소 처리

2. **`DraggableScheduleItem`**

   - 드래그 가능한 장소 항목
   - 드래그 핸들러
   - 드롭 존 표시

3. **`DayHeader`**

   - 일차 헤더 (드래그 불가, 일반 스크롤 요소)
   - 일차 정보 표시 (날짜, 요일)
   - 드롭 존 역할 (일차 헤더 아래에 드롭 가능)
   - **참고**: 스크롤 시 상단에 고정되는 sticky header가 아님. 일반 스크롤과 함께 움직임

4. **`DropZone`**

   - 장소 사이 또는 일차 헤더 아래의 드롭 존
   - 드롭 가능 위치 시각적 표시

5. **`EditModeToolbar`**
   - 편집 모드 하단 툴바
   - 편집 종료/경로 재계산 버튼
   - 자동 저장 상태 표시 (저장 중/저장됨/에러)

### 수정할 기존 컴포넌트

1. **`DayContentPanel`**

   - 편집 모드 prop 추가
   - 드래그 앤 드롭 지원

2. **`ScheduleItem`**

   - 편집 모드에서 삭제 버튼 표시
   - 드래그 핸들러 연결

3. **`ItineraryEditView`**
   - 모든 일차를 세로로 나열하는 컨테이너
   - 스크롤 가능한 영역
   - 일차 간 드래그 앤 드롭 지원

## 데이터 구조

### 편집 중 상태

```typescript
interface EditState {
  isEditing: boolean;
  originalItinerary: DailyItinerary[];
  editedItinerary: DailyItinerary[];
  saveStatus: "idle" | "saving" | "saved" | "error";
  lastSavedAt?: Date;
  changes: {
    moved: Array<{
      placeId: string;
      fromDay: number;
      fromOrder: number;
      toDay: number;
      toOrder: number;
    }>;
    added: Array<{
      placeId: string;
      day: number;
      order: number;
    }>; // 새로 추가된 장소
    deleted: string[]; // placeId[]
    durationChanged: Array<{
      placeId: string;
      oldDuration: number;
      newDuration: number;
    }>; // 체류 시간 변경
    fixedScheduleChanged: boolean; // 고정 일정 변경 여부
  };
}
```

### 저장 시 변환

```typescript
// 편집된 순서 → DailyItinerary 형식
function convertEditedToItinerary(
  edited: EditedScheduleItem[],
  original: DailyItinerary[],
): DailyItinerary[] {
  // 1. 일차별로 그룹화
  // 2. order 재할당
  // 3. 시간 재계산
  // 4. transportToNext 업데이트 (선택적)
}
```

## 사용자 플로우

### 기본 플로우

1. `/my/trips/[tripId]` 페이지 접속
2. "편집 모드" 버튼 클릭
3. 장소 드래그 앤 드롭으로 순서 변경
4. 변경사항 자동 저장 (500ms debounce)
5. 필요시 다른 일차로 이동
6. 변경사항 자동 저장
7. (선택) 새 장소 추가 → 자동 저장
8. (선택) 체류 시간 변경 → 자동 저장
9. "편집 종료" 버튼 클릭하여 읽기 모드로 복귀

### 일차 간 이동 플로우

1. 편집 모드 진입
2. 모든 일차의 일정이 세로로 표시됨
3. 1일차의 장소를 드래그 시작
4. 스크롤하면서 2일차 영역으로 드래그
5. 2일차의 특정 위치(장소 사이 또는 일차 헤더 아래)에 드롭 존 표시
6. 드롭 → 해당 위치에 삽입
7. 시간 자동 재계산 (1일차와 2일차 모두, 기존 이동 시간 데이터 사용)
8. 변경사항 자동 저장

### 경로 재계산 플로우

1. 편집 모드에서 순서 변경 완료 (자동 저장됨)
2. "경로 재계산" 버튼 클릭
3. 로딩 표시 (각 구간별 API 호출 중)
4. 순서는 유지한 채 실제 경로 정보만 업데이트
5. 시간 자동 재계산 (실제 이동 시간 반영)
6. 자동 저장 완료

**참고**: 순서를 다시 최적화하고 싶다면 편집 모드를 종료하고 "일정 최적화하기" 버튼을 다시 눌러야 함

## 기술 스택

- **드래그 앤 드롭**: `@dnd-kit/core`, `@dnd-kit/sortable`
- **상태 관리**: React `useState`, `useReducer`
- **애니메이션**: CSS transitions, Framer Motion (선택적)

## 고려사항

### 성능

- 대량 장소 처리 시 가상화 고려
- 드래그 중 리렌더링 최소화

### UX

- 드래그 시작 피드백 (햅틱, 시각적)
- 드롭 가능 위치 명확히 표시
- 실수 방지 (확인 다이얼로그)

### 데이터 일관성

- 고정 일정 시간 충돌 검증
- 일과 시간 범위 검증
- 순서 변경 시 기존 이동 시간 데이터의 한계 인지
  - 순서가 바뀌면 기존 A→B 시간을 A→C에 사용할 수 없음
  - 따라서 경로 재계산이 필요할 수 있음을 사용자에게 안내

### 경로 재계산 최적화

#### 차량 모드

- **거리 행렬 캐싱**: 최적화 시 생성된 거리 행렬을 메모리나 DB에 캐싱
- **순서 변경 시**: 거리 행렬에서 즉시 조회 (API 호출 0회)
- **장소 추가 시**: 새로 생긴 구간만 API 호출 (최소화)
  - 예: A → B → C에서 A와 B 사이에 X 추가 → A→X, X→B만 API 호출
- **성능**: 순서 변경은 즉시 완료, 장소 추가는 새로 생긴 구간만 시간 소요

#### 대중교통 모드

- **동일한 구간은 시간 관계없이 재사용**: API 한정량 절약을 위해 동일한 구간은 기존 정보 재사용
- **시간만 조정**: 동일한 구간은 소요 시간은 그대로, 출발/도착 시간만 조정
- **새로 생긴 구간만 API 호출**: 순서 변경이나 장소 추가로 새로 생긴 구간만 API 호출
- **API Rate Limit**: 필요한 구간만 호출하므로 rate limit 관리
- **로딩 시간**: 새로 생긴 구간이 많을수록 시간 소요 (진행률 표시 필요)
- **에러 처리**: 일부 구간 API 호출 실패 시 처리 방안
- **순서 보장**: 경로 재계산 중에도 사용자가 정한 순서는 절대 변경되지 않음
- **최적화와의 구분**: 사용자가 혼동하지 않도록 명확한 UI/메시지

#### 공통

- **진행률 표시**: "3/10 구간 완료" (재사용 구간은 즉시 완료로 표시)
- **근사치 사용 안 함**: 모든 구간은 기존 정보 재사용 또는 실제 API 호출
- **사용자 안내**: 차량 모드는 대부분 즉시 완료, 대중교통 모드는 새로 생긴 구간만 시간 소요

## 다음 단계

1. 드래그 앤 드롭 라이브러리 선택 및 설치
2. `ItineraryEditMode` 컴포넌트 구현
3. `DraggableScheduleItem` 구현
4. 저장 로직 구현
5. 테스트 및 피드백 반영
